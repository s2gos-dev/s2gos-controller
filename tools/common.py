#  Copyright (c) 2025 by ESA DTE-S2GOS team and contributors
#  Permissions are hereby granted under the terms of the Apache 2.0 License:
#  https://opensource.org/license/apache-2-0.

import datetime
import re
import subprocess
from pathlib import Path
from typing import Any, Final

from .openapi import OAMethod

S2GOS_PATH: Final = Path(__file__).parent.parent.resolve()
OPEN_API_PATH: Final = S2GOS_PATH / "openapi.yaml"

C_TAB: Final = "    "
D_TAB: Final = "  "

_REF_PREFIX = "#/components/schemas/"

_PY_TYPES = {
    "null": "None",
    "boolean": "bool",
    "integer": "int",
    "number": "float",
    "string": "str",
    "array": "list[Any]",
    "object": "dict[str, Any]",
}


def write_file(generator_name: str, file_path: Path, code_parts: list[str]):
    with file_path.open("wt") as stream:
        stream.write(f"# generated by {generator_name}:\n")
        stream.write(f"#   filename:  {file_path.name}:\n")
        stream.write(f"#   timestamp: {datetime.datetime.now().isoformat()}\n")
        stream.write("\n")
        for line in code_parts:
            stream.write(line)

    print(f"âœ” Generated {file_path}")
    subprocess.run(["ruff", "format", str(file_path)])
    subprocess.run(["ruff", "check", "--fix", str(file_path)])


def parse_responses(
    method: OAMethod, models: set[str], skip_errors: bool = False
) -> tuple[dict[str, tuple[str, list[str]]], dict[str, tuple[str, list[str]]]]:
    return_types: dict[str, tuple[str, list[str]]] = {}
    error_types: dict[str, tuple[str, list[str]]] = {}
    if method.responses:
        for key, response in method.responses.items():
            status_code = int(key)
            description = response.description
            desc_lines = description.split("\n") if description else []
            if response.content:
                json_content = response.content.get("application/json")
                if json_content and json_content.schema_:
                    if 200 <= status_code < 300:
                        response_type = to_py_type(
                            json_content.schema_, "responses", models
                        )
                        return_types[key] = response_type, desc_lines
                    elif not skip_errors:
                        response_type = to_py_type(
                            json_content.schema_, "responses", models
                        )
                        error_types[key] = response_type, desc_lines
    return return_types, error_types


def to_py_type(
    schema: dict[str, Any],
    path: str,
    models: set[str],
    optional: bool = False,  # noqa: F821
) -> str:
    # print(path, f"{schema!r}")
    ref_uri: str | None = schema.get("$ref")
    if ref_uri:
        assert ref_uri.startswith(_REF_PREFIX)
        component_name = ref_uri[len(_REF_PREFIX) :]
        type_name = component_name[0].upper() + component_name[1:]
        models.add(type_name)
        return type_name

    one_of: list[dict] | None = schema.get("oneOf")
    if one_of:
        return to_py_union_type(
            [to_py_type(s, path + f".oneOf[{i}]", models) for i, s in enumerate(one_of)]
        )

    any_of: list[dict] | None = schema.get("anyOf")
    if any_of:
        return to_py_union_type(
            [to_py_type(s, path + f".anyOf[{i}]", models) for i, s in enumerate(any_of)]
        )

    all_of: list[dict] | None = schema.get("allOf")
    if all_of:
        for i, s in enumerate(all_of):
            if s.get("$ref"):
                return to_py_type(s, path + f".allOf[{i}]", models)
        for i, s in enumerate(all_of):
            if s.get("type"):
                return to_py_type(s, path + f".allOf[{i}]", models)
        print(f"warn: cannot convert {path}.allOf")

    enum_ = schema.get("enum")
    if enum_:
        return f"Literal[{', '.join(to_py_literal(v) for v in enum_)}]"

    const = schema.get("const", ...)
    if const is not ...:
        return f"Literal[{to_py_literal(const)}]"

    json_type = schema.get("type")
    if json_type == "array":
        items_schema = schema.get("items")
        item_type = to_py_type(items_schema, path + ".type", models)
        py_type = f"list[{item_type}]"
    elif isinstance(json_type, str):
        py_type = _PY_TYPES[json_type]
    elif isinstance(json_type, (list, tuple)):
        py_type = to_py_union_type([_PY_TYPES[t] for t in json_type])
    else:
        print(f"warn: cannot convert {path}")
        py_type = "Any"
    return to_py_union_type([py_type, "None"]) if optional else py_type


def camel_to_snake(name: str) -> str:
    """
    Convert a camelCase or PascalCase string to snake_case.
    Ensures that the output is also a valid identifier in Python, C, or Java.

    Args:
        name (str): A valid camelCase or PascalCase identifier.

    Returns:
        str: The converted snake_case identifier.
    """
    # Add underscore between lowercase-to-uppercase transitions
    name = re.sub(r"(?<=[a-z0-9])([A-Z])", r"_\1", name)
    # Add underscore between adjacent capitals and followed by lowercase (e.g., "HTTPServer" -> "http_server")
    name = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", name)
    # Convert to lowercase
    snake = name.lower()
    # If it starts with a digit, prepend an underscore to make it a valid identifier
    if snake and snake[0].isdigit():
        snake = "_" + snake
    return snake


def to_py_literal(value) -> str:
    return repr(value)


def to_py_union_type(py_types: list[str]) -> str:
    return " | ".join(py_types)
